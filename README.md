# Spring Framework

|Project|Notes|
|--|--|
|[usingBeanAnnotation](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/usingBeanAnnotation)|Spring **@Bean** Annotation is applied on a method to specify that it returns a bean to be managed by Spring context. Spring Bean annotation is usually declared in Configuration classes methods. In this case, bean methods may reference other **@Bean** methods in the same class by calling them directly.|
|[noUniqueBeanDefinitionException](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/noUniqueBeanDefinitionException)|When you have more than one bean of a given type, you need to tell Spring which bean you wish it to use for dependency injection. If you fail to do so, Spring will throw a **NoUniqueBeanDefinitionException** exception, which means thereâ€™s more than one bean which would fulfill the requirement. To avoid this we can fetch the bean from the context by mentioning its name.|
|[namingBeans](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/namingBeans)|Naming a Spring bean is quite helpful when we have multiple implementations of the same type. This is because it'll be ambiguous to Spring to inject a bean if our beans don't have unique names.|
|[usingPrimaryAnnotation](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/usingPrimaryAnnotation)|**@Primary** is used to give higher preference to a bean when there are multiple beans of the same type. **@Primary** bean is the one which Spring will choose if it has multiple options and you don't specify a name. In other words, it is the default bean that Spring Context will consider in case of confusion due to multiple beans present of the same type.|
|[usingComponentAnnotation](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/usingComponentAnnotation)|**@Component** is one of the most commonly used stereotype annotation bu developers. Using this we can easily create and add a bean to the Spring context by writing less code compared to the **@Bean** option. With stereotype annotations, we need to add the annotation above the class for which we need to have an instance in the Spring context. Using **@ComponentScan** annotation over the configuration class, instruct the Spring on where to find the class you marked with stereotype annotations.|
|[usingPostConstructAnnotation](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/usingPostConstructAnnotation)|Spring calls the methods annotated with **@PostConstruct** only once, just after the initialization of bean properties. Keep in mind that these methods will run even if there's nothing to initialize. One possible use of **@PostConstruct** is populating a database. For instance, during development, we might want to create some default users.|
|[usingPreDestroyAnnotation](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/usingPreDestroyAnnotation)|A method annotated with **@PreDestroy** runs only once, just before Spring removes our bean from the application context. Same as with **@PostConstruct**, the methods annotated with **@PreDestroy** can have any access level, but can't be static.|
|[usingRegisterBean](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/usingRegisterBean)|Sometimes, instead of simply creating beans for classes we want to create beans based on some conditions. To do so we can use **registerBean** method which takes in name of the bean, type or class of the bean and supplier returning the object instance that we want to add to the Spring context.|
|[usingXMLConfiguration](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/usingXMLConfiguration)|In the initial version of the Spring, the bean and the other configuration used to be done using XML. But over the time, Spring team brings annotation based configurations to make developers life easy. Currently XML configurations are only seen in the older applications.|
|[wiringBeansWMethodCall](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/wiringBeansWMethodCall)|Bean wiring is the process of combining beans with Spring container. The required beans are to be informed to the container and how the container should use dependency injection to tie them together, at the time of wiring the beans. One way to do it is to call the bean method from the another bean method.|
|[wiringBeansWMethodParameter](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/wiringBeansWMethodParameter)|Another way of wiring is to pass the bean as a method parameter to the other bean method. Spring will make sure that only one dependee bean is created and is created before the dependent bean.|
|[wiringBeansWAutowiring](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/wiringBeansWAutowiring)|**@Autowired** allows Spring to resolve and inject collaborating beans into our bean. The **@Autowired** annotation in spring automatically injects the dependent beans into the associated references of a POJO class. This annotation will inject the dependent beans by matching the data-type (i.e. byType). Spring allows **@Autowired** on **field or property**, on the **setter method**, on **constructor**. **@Autowired(required = false)** will help to avoid the **NoUniqueBeanDefinitionException** if the bean is not available during autowiring process.|
|[autowiringInsideSpring](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/autowiringInsideSpring)|Field or Property injection, using annotations on bean variables for dependency injection, is essentially injecting directly into the field through reflection, which should be one of the most common methods seen in development. Field injection also has the limitation of not being able to use the **@Autowired** annotation on fields declared as **final/immutable**, since these fields must be initialized when the class is instantiated.|
|[autowiringSetterMethod](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/autowiringSetterMethod)|Injects the dependent object into the dependent class by calling the setter function provided by the member variable. Setter injection is used if there are optional mutable dependencies, and optional dependencies can be specified with **@Autowired(required = false)**. Constructor injection cannot do this, as it is applied to all constructors.|
|[autowiringConstructor](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/autowiringConstructor)|Injects the dependent object into the dependency via the constructor parameters and at the time of initializing the object.|
|[circularDependencies](https://github.com/sahug/spring-framework/tree/main/src/main/java/org/examples/circularDependencies)|A circular dependency happens when two beans are waiting for each other to create inside the Spring context in order to do Autowiring. In such scenarios Spring will throw UnsatisfiedDependencyException due to circular reference.|
